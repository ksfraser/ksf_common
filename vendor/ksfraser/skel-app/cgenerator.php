<?php

/*20090308 KF Eventum issue #27 */
//Merge the various versions of the generator

	require_once('data/db.php');
	define ("SUCCESS", 1);
	define ("TRUE", 1);
	define ("FALSE", 0);

/* Homebuilt code generator.  Will go into MySQL db to get the description of the tables, will build classes to handle CRUD for those tables, will include SQL scripts to create tables, etc.

GUI generation could also use XML descriptions.
*/


/*
Want to build modules in file named TABLENAME.c


//module TABLENAME {
	var $fieldspec = array('firstcol', 'secondcol', ...);
	var $firstcol = array( value, dbtype, htmltype, ...); //Comment on datatype, size, etc.
	var $secondcol;
	...
	function __contsructor()
	{
		return;
	}
	function Setfirstcol($value)
	{
		$this->firstcol = $value;
		return SUCCESS;
	}
	function Getfirstcol()
	{
		return $this->firstcol;
	}
	function Validatefirstcol()
	{
		if (iscoltype($value))
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	...

*/

//20090103 Eventum project framework issue #35
//Trigger loops when a table updates a field, and then triggers its own proc to update a different table with the same field
//This leads to the same trigger being re-triggered due to namespaces not being in play.
//Changing how the pre/post triggers are named will break existing triggers
//Propose 2 stage approach - have the triggers have to be in the same class (inherited).  If so, don't call triggered.c
//Only if there isn't the triggered name within the same class then look at triggered.c


class my_generator
{
	var $tablename;
	var $query;
	var $result;
	var $db; //connection, not name
	var $classdir;
	var $datadir;
	var $viewdir;
	var $controllerdir;
	var $controllername;

function __construct($table)
{
	$this->Settablename($table);
	$this->includefilename = $this->tablename . ".h"; 
	$this->classfilename = $this->tablename . ".c"; 
	echo "Table Name: $table";
	$this->classdir = "src";
	$this->datadir = "data";
	$this->viewdir = "view";
	$this->controllerdir = "../controller";
	$this->controllername = "controller.c";
	return SUCCESS;
}
function my_generator($table)
{
	return $this->__construct($table);
}

function sql_GetObjectQuery()
{
	return "select * from $this->tablename";
}

function fp_OpenClassFile()
{
	$filename = $this->classdir . "/" . $this->classfilename;
	$fp = fopen( $filename, "w" );
	if ($fp == NULL)
	{
		//error - log it
		echo "Couldn't open include File $filename";
		echo "Check that the dir exists";
		exit(0);
	}
	else
	{
		return $fp;
	}
}

function fp_OpenClassHeaderFile()
{
/*No longer want to write the include file as it is up to dev's
 * to use the file to extend the base classes
 */
	return NULL;
	$filename = $this->classdir . "/" . $this->includefilename;
	$fp = fopen( $filename, "w" );
	if ($fp == NULL)
	{
		//error - log it
		echo "Couldn't open header File $this->includefilename";
		echo "Check that the dir exists";
		exit(0);
	}
	else
	{
		return $fp;
	}
}

function fp_OpenXSLTFile()
{
	$filename = $this->viewdir . "/" . $this->tablename . ".xslt"; 
	$fp = fopen( $filename, "w" );
	if ($fp == NULL)
	{
		//error - log it
		echo "Couldn't open xslt File $filename";
		echo "Check that the dir exists";
		exit(0);
	}
	else
	{
		return $fp;
	}
}

function b_CreateHeader()
{
/*Don't create include file*/
	return SUCCESS;
	$headerstring = " \n";
	$headerstring .= "?>";
	$fp = $this->fp_OpenClassHeaderFile();
	fwrite( $fp, $headerstring );
	fclose ($fp);
	return SUCCESS;
}

/*20090308 KF Eventum issue #27 */
//Merge the various versions of the generator
//function b_CreateClassFile($queryresults, $colres, $colres2, $app)
function b_CreateClassFile( $queryresults, $colres, $colres2, $app, $objectmeta = NULL )
{
//!#27
	$funcstring = "";
	$colstring = "";
	$varstring = "";
	$funcstring2 = "";
	$ExtraSQL = "";
	$includestring = "";
	$headerstring = "";
	
	$filestring = "\n";
	$filestring .= "/*This file was generated by calling php " . __FILE__  . " $app */\n\n";
//	$filestring .= "#ifndef " . $this->tablename . "\n";
//	$filestring .= "#define " . $this->tablename . "\n\n";
	$filestring .= "#include <string.h>\n";
	$filestring .= "#include <stdlib.h>\n";
	$filestring .= "#define SUCCESS 1\n";
	$filestring .= "#define FAILURE -1\n";

	//$filestring .= "class $this->tablename extends generictable \n{\n";
	$filestring .= "//module  $this->tablename\n\n";
/*20090308 KF Eventum issue #27 */
//Merge the various versions of the generator
	//If the object metadata is set, include it here
//	echo "\nMetadata object type\n";
//	var_dump( $objectmeta );
//	echo "\n";
	if( isset( $objectmeta ) )
	{
		$filestring .= "\tchar* pretty_name;\n";
                $filestring .= "\tchar* pretty_plural;\n";
                $filestring .= "\tchar* pageheader;\n";
                $filestring .= "\tchar* pagefooter;\n";
		if( !empty( $objectmeta['defaultsort'] ))
		{
			$defaultsortstring .= $objectmeta['defaultsort'] . " " . $objectmeta['defaultsortdir'];
		}
		else
			$defaultsortstring = "";
        }
//!#27
	$filestring .= "\tchar* observers;\n";
	$filestring .= "\tchar* classname;\n";
	$filestring .= "\tchar* querytablename;\n";
	$filestring .= "\n\n\n";
	//Build Variables List
	$fieldstring = "         \t\$this->fieldlist = array('";
	$searchablestring = "         \t\$this->searchlist = array(";
	$prikeystring = "         \t/* primary key: ";
	$varstring .=   "\t\tchar* data; /*data passed in by other calls*/\n\n";
	$varstring .= "/********************************************************\n";
	$varstring .= " *\n";
	$varstring .= " *\tThis section is the table columns\n";
	$varstring .= " *\n";
	$varstring .= " *******************************************************/\n";
	$constructorvar = "";
	$constcount = 0;
	while ($res = $this->GetRow($colres)) //implicit !NULL
	{	
		//Need to decode the abstract_data_type to get C types
		if (               strtoupper($res['abstract_data_type']) == 'INTEGER'
                                OR strtoupper($res['abstract_data_type']) == 'SMALLINT'
                                OR strtoupper($res['abstract_data_type']) == 'BIGINT'
                                OR strtoupper($res['abstract_data_type']) == 'TINYINT'
                                OR strtoupper($res['abstract_data_type']) == 'INT'
                                OR strtoupper($res['abstract_data_type']) == 'MEDIUMINT'
                                OR strtoupper($res['abstract_data_type']) == 'DECIMAL'
                                OR strtoupper($res['abstract_data_type']) == 'DOUBLE'
                                OR strtoupper($res['abstract_data_type']) == 'NUMBER'
                                OR strtoupper($res['abstract_data_type']) == 'REAL'
                                OR strtoupper($res['abstract_data_type']) == 'FLOAT'
                                OR strtoupper($res['abstract_data_type']) == 'PERCENT'
                                OR strtoupper($res['abstract_data_type']) == 'CURRENCY'
                                OR strtoupper($res['abstract_data_type']) == 'DOLLAR' )
                        {
				$ctype = "float ";
				$varind = "f";
			}
 		else if (
                                        (strtoupper($res['abstract_data_type']) == 'DATETIME')
                                OR      (strtoupper($res['abstract_data_type']) == 'DATE')
                                OR      (strtoupper($res['abstract_data_type']) == 'TIMESTAMP')
                                OR      (strtoupper($res['abstract_data_type']) == 'TIME')
                                OR      (strtoupper($res['abstract_data_type']) == 'YEAR')
                                )
                        {
				$ctype = "char* ";
				$varind = "pc";
			}
		else if (
                                        (strtoupper($res['abstract_data_type']) == 'BINARY')
                                OR      (strtoupper($res['abstract_data_type']) == 'SET')
                                OR      (strtoupper($res['abstract_data_type']) == 'ENUM')
                                OR      (strtoupper($res['abstract_data_type']) == 'BLOB')
                                OR      (strtoupper($res['abstract_data_type']) == 'LONGBLOB')
                                OR      (strtoupper($res['abstract_data_type']) == 'MEDIUMBLOB')
                                OR      (strtoupper($res['abstract_data_type']) == 'TINYBLOB')
                                OR      (strtoupper($res['abstract_data_type']) == 'TEXT')
                                OR      (strtoupper($res['abstract_data_type']) == 'LONGTEXT')
                                OR      (strtoupper($res['abstract_data_type']) == 'MEDIUMTEXT')
                                OR      (strtoupper($res['abstract_data_type']) == 'TINYTEXT')
                                OR      (strtoupper($res['abstract_data_type']) == 'VARBINARY')
                                )
                        {
				$ctype = "char* ";
				$varind = "pc";
			}
		else
                        {
				$ctype = "char* ";
				$varind = "pc";
			}
		$fieldstring .= $res['column_name'];
		if ($res['issearchable'] == 1)
		{
			$searchablestring .= "'" . $res['column_name'] . "', ";
		}
		if (
			($res['prikey'] == 'y')
			OR ($res['prikey'] == 'Y')
		   )
		{
			$prikeystring .= "'" . $res['column_name'] . "', ";
			if( $constcount > 0 )
				$constructorvar .= ", ";
			$constructorvar .= $ctype . " " . $res['column_name'];
			$constcount++;
			$constructorset[] = $res['column_name'];
		}
		$fieldstring .= "', '";
		$totalcount = count ($res);
		$arrcount = count( $res[0] );
		$colcount = $totalcount / $arrcount;
		$keys = $arrcount / 2;
		for ($j = 0; $j < $colcount; $j++)
		{
		  for ($i = 0; $i < $keys; $i++)
		  {
			  //Errors out about unsetting string offsets
			//unset( $res[$j]['$i'] );
		  }
	  	}
	/*	
		foreach ($res as $key => $value)
		{
			if (FALSE == is_numeric($key))
			{
				$colstring .= "         \t\$this->fieldspec['" . $res['column_name'] . "']['$key'] = '$value';\n";
			}
		}
		$colstring .= "         \t\$this->fieldspec['" . $res['column_name'] . "']['postinsert'] = 'Post" . $res['column_name'] . "Insert';\n";
		$colstring .= "         \t\$this->fieldspec['" . $res['column_name'] . "']['postupdate'] = 'Post" . $res['column_name'] . "Update';\n";
		$colstring .= "         \t\$this->fieldspec['" . $res['column_name'] . "']['postdelete'] = 'Post" . $res['column_name'] . "Delete';\n";
		$colstring .= "         \t\$this->fieldspec['" . $res['column_name'] . "']['preinsert'] = 'Pre" . $res['column_name'] . "Insert';\n";
		$colstring .= "         \t\$this->fieldspec['" . $res['column_name'] . "']['preupdate'] = 'Pre" . $res['column_name'] . "Update';\n";
		$colstring .= "         \t\$this->fieldspec['" . $res['column_name'] . "']['predelete'] = 'Pre" . $res['column_name'] . "Delete';\n";
	*/
//If we decide to include the default value in the class
		//$varstring .=   "         var $" . $res['column_name'] . " = " . $res['default_value'] . ";\n\t\t /*" . $res['pretty_name'] . " */\n";
//20090926 KF Add db_data_type in comments
		$varstring .=   "         /* " . $res['db_data_type'] . " */ ";
		$varstring .= "$ctype";
		$varstring .= $varind . $res['column_name'] . ";\n\t\t /*" . $res['pretty_name'] . " */\n";
/*
		$dbactions = array( "Insert", "Update", "Delete" );
		foreach ($dbactions as $value)
		{
			$funcstring2 .= "         void* Pre" . $res['column_name'] . $value . "( char* data )\n";
			$funcstring2 .= "         {\n";
			$funcstring2 .= "         \tSetdata( data );\n";
				//Eventum framework issue #35
			$funcstring2 .= "                 if ( is_callable( " . $this->tablename . "_Pre" . $res['column_name'] . $value . " ) )\n";
			$funcstring2 .= "	            return " . $this->tablename . "_Pre" . $res['column_name'] . $value . "( \$this );\n";
			$funcstring2 .= "                 else if ( is_callable( " . $this->tablename . "_Pre" . $res['column_name'] . $value . " ) )\n";
			$funcstring2 .= "	            return " . $this->tablename . "_Pre" . $res['column_name'] . $value . "( \$this );\n";
			$funcstring2 .= "                 else if ( is_callable( Pre" . $res['column_name'] . $value . " ) )\n";
			//$funcstring2 .= "                 if ( is_callable( Pre" . $res['column_name'] . $value . " ) )\n";
				//!#35
			$funcstring2 .= "	            return Pre" . $res['column_name'] . $value . "( this );\n";
			$funcstring2 .= "                 else return;\n";
			$funcstring2 .= "         }\n";
			$funcstring2 .= "         void* Post" . $res['column_name'] . $value . "( char* data, float lastinsert  )\n";
			$funcstring2 .= "         {\n";
			$funcstring2 .= "         \tSetdata( data );\n";
				//Eventum framework issue #35
			$funcstring2 .= "                 if ( is_callable( " . $this->tablename . "_Post" . $res['column_name'] . $value . " ) )\n";
			$funcstring2 .= "	            returnval =  " . $this->tablename . "_Post" . $res['column_name'] . $value . "( \$this );\n";
			$funcstring2 .= "                 else if ( is_callable( " . $this->tablename . "_Post" . $res['column_name'] . $value . " ) )\n";
			$funcstring2 .= "	            returnval =  " . $this->tablename . "_Post" . $res['column_name'] . $value . "( this );\n";
			$funcstring2 .= "                 else if ( is_callable( Post" . $res['column_name'] . $value . " ) )\n";
			//$funcstring2 .= "                 if ( is_callable( Post" . $res['column_name'] . $value . " ) )\n";
				//!#35
			$funcstring2 .= "	            returnval =  Post" . $res['column_name'] . $value . "( this );\n";
			$funcstring2 .= "                 else returnval = NULL;\n";
			$funcstring2 .= "                 ObserverNotify( \"" . $value . "\", \"" . $res['column_name'] . "\" );\n";
			$funcstring2 .= "                 return \$returnval;\n";
			$funcstring2 .= "         }\n";
		}
*/
//Don't need the set/get in PHP the way I am handling elsewhere
		$headerstring .= "         bool Set" . $res['column_name'] . "( " . $ctype . " value );\n";
		$funcstring2 .= "         bool Set" . $res['column_name'] . "( " . $ctype . " value )\n";
		$funcstring2 .= "         {\n";
		$funcstring2 .= "                 " . $varind . $res['column_name'] . " = value;\n";
		$funcstring2 .= "	          return " . SUCCESS . ";\n";
		$funcstring2 .= "         }\n";
		$headerstring2 .= "         /* " . $res['db_data_type'] . " */ $ctype Get" . $res['column_name'] ."();\n";
		$funcstring2 .= "         /* " . $res['db_data_type'] . " */ $ctype Get" . $res['column_name'] ."()\n";
		$funcstring2 .= "         {\n  ";
		$funcstring2 .= "                  return " . $varind . $res['column_name'] . ";\n";
		$funcstring2 .= "         }\n";
		$funcstring2 .= "         bool Validate" . $res['column_name'] . "()\n";
		$funcstring2 .= "         {\n";
		/*
		$funcstring2 .= "                  if (" . iscoltype . "(\$value))\n";
		$funcstring2 .= "                  {\n";
		$funcstring2 .= "                           return TRUE;\n";
		$funcstring2 .= "                  }\n";	
		$funcstring2 .= "                  else\n";	
		$funcstring2 .= "                  {\n";
		$funcstring2 .= "                           return FALSE;\n";
		$funcstring2 .= "                  }\n";
*/
		$funcstring2 .= "         }\n";
	}
	$fieldstring = rtrim( $fieldstring, "', "); //remove the last comma as it is extra due to the above while loop.
	$searchablestring = rtrim( $searchablestring, ", ");
	$prikeystring = rtrim( $prikeystring, ", ");
	$fieldstring .= "');\n";
	$searchablestring .= ");\n";
	$prikeystring .= " */\n";
	$constructstring = "         void $this->tablename( " . $constructorvar . " )\n";
		$constructstring .= "         {\n";
		$constructstring .= "         \tint iPtrSize;\n";
		$constructstring .= "         \tiPtrSize = strlen( \"" . $objectmeta['pretty_name'] . "\" );\n";
		$constructstring .= "         \tpretty_name = (char*)malloc( iPtrSize + 1 );\n";
		$constructstring .= "         \tmemset( pretty_name, '0', iPtrSize + 1 );\n";
		$constructstring .= "         \tstrncpy( pretty_name, \"" . $objectmeta['pretty_name'] . "\", iPtrSize );\n";
		$constructstring .= "\n";
		$constructstring .= "         \tiPtrSize = strlen( \"" . $objectmeta['pretty_plural'] . "\" );\n";
		$constructstring .= "         \tpretty_plural = (char*)malloc( iPtrSize + 1 );\n";
		$constructstring .= "         \tmemset( pretty_plural, '0', iPtrSize + 1 );\n";
		$constructstring .= "         \tstrncpy( pretty_plural, \"" . $objectmeta['pretty_plural'] . "\", iPtrSize );\n";
		$constructstring .= "\n";
		$constructstring .= "         \tiPtrSize = strlen( \"" . $objectmeta['pageheader'] . "\" );\n";
		$constructstring .= "         \tpageheader = (char*)malloc( iPtrSize + 1 );\n";
		$constructstring .= "         \tmemset( pageheader, '0', iPtrSize + 1 );\n";
		$constructstring .= "         \tstrncpy( pageheader, \"" . $objectmeta['pageheader'] . "\", iPtrSize );\n";
		$constructstring .= "\n";
		$constructstring .= "         \tiPtrSize = strlen( \"" . $objectmeta['pagefooter'] . "\" );\n";
		$constructstring .= "         \tpagefooter = (char*)malloc( iPtrSize + 1 );\n";
		$constructstring .= "         \tmemset( pagefooter, '0', iPtrSize + 1 );\n";
		$constructstring .= "         \tstrncpy( pagefooter, \"" . $objectmeta['pagefooter'] . "\", iPtrSize );\n";
		$constructstring .= "\n";
		$constructstring .= "         \tSetquerytablename( \"" . $this->tablename . "\" );\n";
		$constructstring .= "         \tSetclassname( \"" . $this->tablename . "\" );\n";
		//Set the passed in variables
		foreach( $constructorset as $vartoset )
		{
			$constructstring .= "         \tSet$vartoset( " . $vartoset . " );\n";
		}
		$constructstring .= $prikeystring;
		$constructstring .= "         \treturn;\n";
		$constructstring .= "         }\n";
	
	$funcstring .= $constructstring;
		//$funcstring .= $fieldstring;
		//$funcstring .= $searchablestring;
		//$funcstring .= "\t\t\$this->defaultsort = '" . $defaultsortstring . "';\n"; 
	//!157
		$funcstring .= $ExtraSQL;

//		$funcstring .= "         void* " . $this->tablename . "()\n";
//		$funcstring .= "         { // Using an older PHP convention in the generator.\n";
//		$funcstring .= "              return this->__construct();\n";
//		$funcstring .= "         }\n";
		$funcstring .= "          bool Setdata( char* data )\n";
		$funcstring .= "         {\n";	
		$funcstring .= "         \tdata = data;\n";	
		$funcstring .= "	         return SUCCESS;\n";	
		$funcstring .= "         }\n";
		$funcstring .= "          bool Setquerytablename( char* querytablename )\n";
		$funcstring .= "         {\n";	
		$funcstring .= "         \tquerytablename = querytablename;\n";	
		$funcstring .= "	         return SUCCESS;\n";	
		$funcstring .= "         }\n";
		$funcstring .= "          bool Setclassname( char* classname )\n";
		$funcstring .= "         {\n";	
		$funcstring .= "         \tclassname = classname;\n";	
		$funcstring .= "	         return SUCCESS;\n";	
		$funcstring .= "         }\n";

		//OBSERVER PATTERN
		$funcstring .= "         bool ObserverRegister( char* observer, int event )\n";
		$funcstring .= "         {\n";	
//		$funcstring .= "                 observers[ event ][] = observer;\n";
//		$funcstring .= "	         return SUCCESS;\n";
		$funcstring .= "	         return FAILURE;\n";
		$funcstring .= "         }\n";
		$funcstring .= "         bool ObserverDeRegister( char *observer )\n";
		$funcstring .= "         {\n";	
		$funcstring .= "                 /*observers[] = array_diff( \$this->observers, array( \$observer) );*/\n";
//		$funcstring .= "	         return SUCCESS;\n";
		$funcstring .= "	         return FAILURE;\n";
		$funcstring .= "         }\n";
		$funcstring .= "         bool ObserverNotify( int event, char *msg )\n";
		$funcstring .= "         {\n";	
//		$funcstring .= "                 if ( isset( observers[event] ) )\n";	
//		$funcstring .= "                 \tforeach ( observers[event] as obs ) \n";
//		$funcstring .= "                 \t{\n";
//		$funcstring .= "                      \t\tobs->notify( event, msg );\n";
//		$funcstring .= "                 \t}\n"; 
//		$funcstring .= "                 /* '00' being used as 'ALL' */\n"; 
//		$funcstring .= "                 if ( isset( observers[00] ) )\n";	
//		$funcstring .= "                 \tforeach ( observers[00] as obs ) \n";
//		$funcstring .= "                 \t{\n";
//		$funcstring .= "                      \t\tobs->notify( event, msg );\n";
//		$funcstring .= "                 \t}\n"; 
//		$funcstring .= "	         return SUCCESS;\n";
		$funcstring .= "	         return FAILURE;\n";
		$funcstring .= "         }\n";
		$funcstring .= "         bool notify( void *object )\n";
		$funcstring .= "         {\n";	
		$funcstring .= "                 //Called when another object we are observing sends us a notification\n";
//		$funcstring .= "	         return SUCCESS;\n";
		$funcstring .= "	         return FAILURE;\n";
		$funcstring .= "         }\n";

		$mstring = "";
		//The codemeta table metadata_functions may have additional functions to be included
		$this->query = "select * from metadata_functions where application = '$app' and table_name = '$this->tablename' and codelanguage = 'c'";
		$this->Query();
		if( isset( $this->result ))
		{
			while( ($row = $this->GetRow($this->result)) != NULL)
			{
		//		var_dump( $row );
				//grab the fields and create functions
				$mfunc = "\t" . $row['returntype'] . " " . $row['function_name'] . "(" . $row['function_arguments'] . ")\n\t{\n";
				$mfuncpurpose = "\t\t/*" . $row['function_purpose'] . "*/";
				$mfuncpurpose .= "\n\t\t/*This function is generated by the generator from codemeta_functions*/\n";
				$mfuncvar = "\t\t" . str_replace( "\r\n", "\n\t\t", $row['function_variables'] ) . "\n";
				$mfuncbody = "\t\t" . str_replace( "\r\n", "\n\t\t", $row['function_body'] ) . "\n";
				$mfuncbody .= "\t\t//If we don't have a return in the body in codemeta, return\n";
				$mfuncbody .= "\t\treturn " . $row['returnvalue'] . ";\n";
				$mfuncbody .= "\t}\n";

				$mstring .= $mfunc . $mfuncpurpose . $mfuncvar . $mfuncbody;
		//		var_dump( $mstring );
			}
		}
			
		
	//Set attributes of the columns into arrays
		$varstring .= "/********************************************************\n";
		$varstring .= " *\n";
		$varstring .= " *\tEnd of section table columns\n";
		$varstring .= " *\n";
		$varstring .= " *******************************************************/\n";
	$output = $filestring . $includestring . $varstring . $funcstring . $funcstring2 . $mstring;
	$output .= "}; /* class $this->tablename */\n";
//	$output .= "#endif //$this->tablename\n";
	$fp = $this->fp_OpenClassFile();
	fwrite( $fp, $output );
	fclose ($fp);

	return SUCCESS;
}

function b_CreateXSLTFile($queryresults, $colres, $colres2)
{	
	
	$topstring = ' <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0" xmlns="HTTP://WWW.W3.ORG/1999/XHTML">';

	$matchstring = '<xsl:template match="/"> <xsl:apply-templates select="ROOT/*" /> </xsl:template>';

	$setstring = '<xsl:template match="RECORDSET"> <xsl:apply-templates/> </xsl:template>';
	$recordstring = '<xsl:template match="RECORD"> <xsl:apply-templates/> </xsl:template>';
	$rowstring = "";
	while ($res = $this->GetRow($colres)) //implicit !NULL
	{	
		$rowstring .= '<xsl:template match="' . $res['column_name'] . '"> <xsl:apply-templates/> </xsl:template>';
	}
	$endstring = '</xsl:stylesheet>';
	
	$output = $topstring . $matchstring . $setstring . $recordstring . $rowstring . $endstring;
	$fp = $this->fp_OpenXSLTFile();
	fwrite( $fp, $output );
	fclose ($fp);

	return SUCCESS;
}

function BuildRegister( $app )
{
        $this->query = "select table_name, column_name from codemeta.metadata_elements where foreign_table = '$this->tablename'";
        $this->db->SetQuery( $this->query );
        $this->db->Query();
        $out = "\n";
        $out .= "function " . $this->tablename . "RegisterOthers()\n";
        $out .= "{\n";

        while( $row = mysql_fetch_array( $this->db->result ) )
        {
                echo "\nRow returned:\n";
                var_dump( $row );
                echo "\n";
                //create $classname.register.c
                $out .= "\t@include_once( '" . $row['table_name'] . ".c' );\n";
                $out .= "\t\$observer = new " . $row['table_name'] . "();\n";
                $out .= "\t\$table->ObserverRegister( \$observer, 'CREATE' );\n";
                $out .= "\t\$table->ObserverRegister( \$observer, 'REPLACE' );\n";
                $out .= "\t\$table->ObserverRegister( \$observer, 'UPDATE' );\n";
                $out .= "\t\$table->ObserverRegister( \$observer, 'DELETE' );\n";
        }
        $out .= "}\n";
        $out .= "?>";
        $filename = $this->classdir . "/" .  $this->tablename . ".register.c";
        echo "\nOutfile = $filename\n";
        $fp = fopen( $filename, "w" );
        if ($fp == NULL)
        {
                //error - log it
                echo "Couldn't open register File $filename";
                echo "Check that the dir exists";
                exit(0);
        }
        echo "Register text: $out\n";
        fwrite( $fp, $out );
        fclose( $fp );
        return SUCCESS;
}


function Settablename($name)
{
	$this->tablename = $name;
	return SUCCESS;
}
function BuildQuery( $app )
{
	//$this->query = "select * from codemeta.metadata_elements where table_name = '$this->tablename'";
	//$this->query = "select * from codemeta.metadata_elements where table_name = '$this->tablename' order by form_sort_key";
	$this->query = "select * from codemeta.metadata_elements where table_name = '$this->tablename' and application='$app' order by form_sort_key";
	return SUCCESS;
}
function ObjectQuery( $app )
{
	$this->query = "select * from codemeta.metadata_object_types where table_name = '$this->tablename' and application='$app'";
	return SUCCESS;
}
function Query()
{
	$this->db = new my_db("localhost", "codemeta", "codemeta", "codemeta");
	$this->db->SetQuery($this->query);
	$this->db->Query();
	$this->result = $this->db->result;
	return SUCCESS;
}
function GetRow($res)
{
	$this->db->result = $res;
	return $this->db->FetchRow();
}

function CreateObjects($app)
{
	$this->BuildQuery( $app );
	$this->Query();
	$res = $this->result;
	$this->ObjectQuery( $app );
	$this->Query();
	$meta = $this->GetRow($this->result);
	$this->b_CreateClassFile($res, $res, $res, $app, $meta);
	//$this->BuildRegister( $app );
	//$this->b_CreateHeader();
	return SUCCESS;
}


function CreateXSLT( $app )
{
	$this->BuildQuery( $app );
	$this->Query();
	$res = $this->result;
	$this->b_CreateXSLTFile($res, $res, $res);
	return SUCCESS;
}


function b_CreateSQLFile($result)
{
	$prikeyar = array();
	$statement = "";
	//$statement .="---\n\r"; 
	//$statement .="--- Table struct for table $this->tablename\n\r"; 
	//$statement .="---\n\r"; 
	$statement .= "DROP TABLE IF EXISTS `$this->tablename`;\n\r";
	$statement .= "CREATE TABLE `$this->tablename` (\n\r";
	while ($row = $this->GetRow($result))
	{
		//Init values
		$column = $type = $size = $unsigned = $zerofill = $NULL = $autoinc = $default = $comment = $PRIKEY = "";
		$column = $row['column_name'];
		$type = $row['db_data_type'];
		$size = $row['c_size'];
		if ($row['c_unsigned'] == 'Y')
		{
			$unsigned = "unsigned";
		}
		if ($row['c_zerofill'] == 'Y')
		{
			$zerofill = "zerofill";
		}
		if (strncmp($row['field_null'], "Y", 1) == 0)
		{
			$NULL = "NULL";
		}
		else
		{
			$NULL = "NOT NULL";
		}	
		if ($row['c_auto_increment'] == 'Y')
		{
			$autoinc = "auto_increment";
		}
		if ($row['prikey'] == 'Y')
		{
			$prikeyar[] = $row['column_name'];
			var_dump($prikeyar);
		}
		$defval = $row['default_value'];
		$default = "default '$defval'";
		$commentval = $row['pretty_name'];
		$comment = "comment '$commentval'";
		//If Comment -> COMMENT ''
		//If default -> default ''
		//PRIKEY = (`key1`, `key2`)
		$statement .= "`$column` $type($size) $unsigned $zerofill $NULL $autoinc $default $comment,\n\r";
	}
	$statement = rtrim( rtrim( $statement ), ",");
	if (count($prikeyar) < 2 AND count($prikeyar) > 0)
	{
		$PRIKEY = "`" . $prikeyar[0] . "`";
	}
	else if( count( $prikeyar ) > 0 )
	{
		$PRIKEY = "`" . $prikeyar[0] . "`";
		foreach ($prikeyar as $key=> $value)
		{
			$PRIKEY .= ", '" . $value . "'";
		}
	}
	$statement .= ", PRIMARY KEY ($PRIKEY)";
	$statement .= ") ENGINE=InnoDB;\n";
	$fp = fopen( "sql/" . $this->tablename . ".sql", "w");
	if ($fp == NULL)
	{
		echo "couldn't open $this->tablename .sql.  Check dir exists";
		exit(0);
	}
	fputs( $fp, $statement );
	fclose( $fp );
}


function CreateTableSQL( $app )
{	
	return;
	$this->BuildQuery( $app );
	$this->Query();
	$res = $this->result;
	$this->b_CreateSQLFile($res, $res, $res);
	$fp = fopen( 'tasks.default.sql', 'a' );
	$description = "$this->tablename";
	$filename = "";
	$tasktype = 'MENU';
	$parent = 'NULL';
	$insertstatementmenu = "INSERT ignore into tasks( tasktype, taskdescription, tasklink, taskparent) values ('$tasktype', '$description', '$filename', '$parent');\n";
	$filename = $this->classdir . '/' . $this->tablename . '.insert.c';
	$description = "Insert into $this->tablename";
	$tasktype = 'TASK';
	$parent = "$this->tablename";
	$insertstatementinsert = "INSERT ignore into tasks( tasktype, taskdescription, tasklink, taskparent) values ('$tasktype', '$description', '$filename', '$parent');\n";
/* 20090629 KF Removing the replace/update/delete menu choices as they are taken care of by the framework by links to the rows.
	$filename = $this->classdir . '/' . $this->tablename . '.replace.c';
	$description = "Replace into $this->tablename";
	$tasktype = 'TASK';
	$parent = "$this->tablename";
	$insertstatementreplace = "INSERT ignore into tasks( tasktype, taskdescription, tasklink, taskparent) values ('$tasktype', '$description', '$filename', '$parent');\n";
	$filename = $this->classdir . '/' . $this->tablename . '.update.c';
	$description = "Update $this->tablename";
	$tasktype = 'TASK';
	$parent = "$this->tablename";
	$insertstatementupdate = "INSERT ignore into tasks( tasktype, taskdescription, tasklink, taskparent) values ('$tasktype', '$description', '$filename', '$parent');\n";
	$filename = $this->classdir . '/' . $this->tablename . '.delete.c';
	$description = "Delete from $this->tablename";
	$tasktype = 'TASK';
	$parent = "$this->tablename";
	$insertstatementdelete = "INSERT into tasks( tasktype, taskdescription, tasklink, taskparent) values ('$tasktype', '$description', '$filename', '$parent');\n";
*/
	$filename = $this->classdir . '/' . $this->tablename . '.search.c';
	$description = "Search $this->tablename";
	$tasktype = 'TASK';
	$parent = "$this->tablename";
	$insertstatementsearch = "INSERT ignore into tasks( tasktype, taskdescription, tasklink, taskparent) values ('$tasktype', '$description', '$filename', '$parent');\n";
	$filename = $this->classdir . '/' . $this->tablename . '.list.c';
	$description = "Show $this->tablename";
	$tasktype = 'TASK';
	$parent = "$this->tablename";
	$insertstatementlist = "INSERT ignore into tasks( tasktype, taskdescription, tasklink, taskparent) values ('$tasktype', '$description', '$filename', '$parent');\n";
	fwrite( $fp, $insertstatementmenu );
	fwrite( $fp, $insertstatementinsert );
	//fwrite( $fp, $insertstatementreplace );
	//fwrite( $fp, $insertstatementupdate );
	//fwrite( $fp, $insertstatementdelete );
	fwrite( $fp, $insertstatementlist );
	fwrite( $fp, $insertstatementsearch );
	fwrite( $fp, "insert into roletask (idtasks) SELECT idtasks FROM tasks t where t.idtasks not in (select idtasks from roletask);\n" );
	fwrite( $fp, "update roletask set roles_id = 1 where roles_id = NULL;\n" );

	fclose( $fp );
	return SUCCESS;
}


function CreatePatterns()
{
	return;
	$prefix = $this->classdir . "/" . $this->tablename;
	//Create the files for list, update, delete, insert
	$filename =  $prefix . ".insert.c"; 
	$fp = fopen( $filename, "w" );
	if ($fp == NULL)
	{
		//error - log it
		echo "Couldn't open $filename .  CHeck the dir exists";
		exit(0);
	}
	$output = "\n";
	$output .= "\$thisclass = '$this->tablename' ;\n";
	$output .= '$mode = "insert";' . "\n";
	$output .= '#include "' . $this->controllerdir . "/" . $this->controllername . '"\n';
	$output .= "\n";
	fwrite( $fp, $output );
	fclose ($fp);

	$filename = $prefix . ".replace.c"; 
	$fp = fopen( $filename, "w" );
	if ($fp == NULL)
	{
		//error - log it
		echo "Couldn't open $filename .  CHeck the dir exists";
		exit(0);
	}
	$output = "\n";
	//$output .= "require_once('" . $this->classfilename . "');\n";
	//$output .= "\$table = new " . $this->tablename . "();\n";
	$output .= "\$thisclass = '$this->tablename' ;\n";
	$output .= '$mode = "replace";' . "\n";
	$output .= "require_once( '" . $this->controllerdir . "/" . $this->controllername . "');\n";
	//$output .= "require_once( '" . $this->controllerdir . "/controller.c');\n";
	//$output .= "require_once( 'controller/controller.c');\n";
	$output .= "?>\n";
	fwrite( $fp, $output );
	fclose ($fp);

	$filename = $prefix . ".update.c"; 
	$fp = fopen( $filename, "w" );
	if ($fp == NULL)
	{
		//error - log it
		echo "Couldn't open $filename .  CHeck the dir exists";
		exit(0);
	}
	$output = "\n";
	//$output .= "require_once('" . $this->classfilename . "');\n";
	//$output .= "\$table = new " . $this->tablename . "();\n";
	$output .= "\$thisclass = '$this->tablename' ;\n";
	$output .= '$mode = "update";' . "\n";
	$output .= "require_once( '" . $this->controllerdir . "/" . $this->controllername . "');\n";
	//$output .= "require_once( 'controller/controller.c');\n";
	//$output .= "require_once( '" . $this->controllerdir . "/controller.c');\n";
	$output .= "?>\n";
	fwrite( $fp, $output );
	fclose ($fp);

	$filename = $prefix . ".delete.c"; 
	$fp = fopen( $filename, "w" );
	if ($fp == NULL)
	{
		//error - log it
		echo "Couldn't open $filename .  CHeck the dir exists";
		exit(0);
	}
	$output = "\n";
	//$output .= "require_once('" . $this->classfilename . "');\n";
	//$output .= "\$table = new " . $this->tablename . "();\n";
	$output .= "\$thisclass = '$this->tablename' ;\n";
	$output .= '$mode = "delete";' . "\n";
	$output .= "require_once( '" . $this->controllerdir . "/" . $this->controllername . "');\n";
	//$output .= "require_once( '" . $this->controllerdir . "/controller.c');\n";
	//$output .= "require_once( 'controller/controller.c');\n";
	$output .= "?>\n";
	fwrite( $fp, $output );
	fclose ($fp);

	$filename = $prefix . ".list.c"; 
	$fp = fopen( $filename, "w" );
	if ($fp == NULL)
	{
		//error - log it
		echo "Couldn't open $filename .  CHeck the dir exists";
		exit(0);
	}
	$output = "\n";
	//$output .= "require_once('" . $this->classfilename . "');\n";
	//$output .= "\$table = new " . $this->tablename . "();\n";
	$output .= "\$thisclass = '$this->tablename' ;\n";
	$output .= '$mode = "list";' . "\n";
	$output .= "require_once( '" . $this->controllerdir . "/" . $this->controllername . "');\n";
	//$output .= "require_once( '" . $this->controllerdir . "/controller.c');\n";
	//$output .= "require_once('controller/controller.c');\n";
	$output .= "?>\n";
	fwrite( $fp, $output );
	fclose ($fp);

	$filename = $prefix . ".search.c"; 
	$fp = fopen( $filename, "w" );
	if ($fp == NULL)
	{
		//error - log it
		echo "Couldn't open $filename .  CHeck the dir exists";
		exit(0);
	}
	$output = "\n";
	//$output .= "require_once('" . $this->classfilename . "');\n";
	//$output .= "\$table = new " . $this->tablename . "();\n";
	$output .= "\$thisclass = '$this->tablename';\n";
	$output .= '$mode = "search";' . "\n";
	$output .= "require_once( '" . $this->controllerdir . "/" . $this->controllername . "');\n";
	//$output .= "require_once( '" . $this->controllerdir . "/controller.c');\n";
	//$output .= "require_once('controller/controller.c');\n";
	$output .= "?>\n";
	fwrite( $fp, $output );
	fclose ($fp);

}

} /*class my_generator*/

$includefilename = ""; 
$classfilename = ""; 

$mydb = new my_db("localhost", "codemeta", "codemeta", "codemeta");
if (isset($argv[1]))
{
	$mydb->SetQuery("select distinct(table_name) from codemeta.metadata_elements where application='$argv[1]'");
}
else
{
	$mydb->SetQuery("select distinct(table_name) from codemeta.metadata_elements");
}
$result = $mydb->Query();
while ($res = $mydb->FetchRow())
{
	foreach ($res as $key => $value)
	{
		if (FALSE == is_numeric( $key ))
		{
			$gen = new my_generator($value);
			$gen->CreateObjects($argv[1]);
			$gen->CreateXSLT( $argv[1] );
			$gen->CreatePatterns();
			$gen->CreateTableSQL( $argv[1] );
		}

	}
}
exit(0);

?>
